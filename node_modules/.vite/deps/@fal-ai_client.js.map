{
  "version": 3,
  "sources": ["../../../libs/client/src/middleware.ts", "../../../libs/client/src/response.ts", "../../../libs/client/src/utils.ts", "../../../libs/client/src/retry.ts", "../../@fal-ai/client/package.json", "../../../libs/client/src/runtime.ts", "../../../libs/client/src/config.ts", "../../../libs/client/src/request.ts", "../../eventsource-parser/src/parse.ts", "../../../libs/client/src/auth.ts", "../../../libs/client/src/streaming.ts", "../../../libs/client/src/queue.ts", "../../@msgpack/msgpack/src/utils/utf8.ts", "../../@msgpack/msgpack/src/ExtData.ts", "../../@msgpack/msgpack/src/DecodeError.ts", "../../@msgpack/msgpack/src/utils/int.ts", "../../@msgpack/msgpack/src/timestamp.ts", "../../@msgpack/msgpack/src/ExtensionCodec.ts", "../../@msgpack/msgpack/src/utils/typedArrays.ts", "../../@msgpack/msgpack/src/Encoder.ts", "../../@msgpack/msgpack/src/encode.ts", "../../@msgpack/msgpack/src/utils/prettyByte.ts", "../../@msgpack/msgpack/src/CachedKeyDecoder.ts", "../../@msgpack/msgpack/src/Decoder.ts", "../../@msgpack/msgpack/src/decode.ts", "../../@msgpack/msgpack/src/utils/stream.ts", "../../@msgpack/msgpack/src/decodeAsync.ts", "../../@msgpack/msgpack/src/index.ts", "../../robot3/dist/machine.js", "../../../libs/client/src/realtime.ts", "../../../libs/client/src/storage.ts", "../../../libs/client/src/client.ts", "../../../libs/client/src/types/common.ts", "../../../libs/client/src/index.ts"],
  "sourcesContent": ["/**\n * A request configuration object.\n *\n * **Note:** This is a simplified version of the `RequestConfig` type from the\n * `fetch` API. It contains only the properties that are relevant for the\n * fal client. It also works around the fact that the `fetch` API `Request`\n * does not support mutability, its clone method has critical limitations\n * to our use case.\n */\nexport type RequestConfig = {\n  url: string;\n  method: string;\n  headers?: Record<string, string | string[]>;\n};\n\nexport type RequestMiddleware = (\n  request: RequestConfig,\n) => Promise<RequestConfig>;\n\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nexport function withMiddleware(\n  ...middlewares: RequestMiddleware[]\n): RequestMiddleware {\n  const isDefined = (middleware: RequestMiddleware): boolean =>\n    typeof middleware === \"function\";\n\n  return async (config: RequestConfig) => {\n    let currentConfig = { ...config };\n    for (const middleware of middlewares.filter(isDefined)) {\n      currentConfig = await middleware(currentConfig);\n    }\n    return currentConfig;\n  };\n}\n\nexport type RequestProxyConfig = {\n  targetUrl: string;\n};\n\nexport const TARGET_URL_HEADER = \"x-fal-target-url\";\n\nexport function withProxy(config: RequestProxyConfig): RequestMiddleware {\n  const passthrough = (requestConfig: RequestConfig) =>\n    Promise.resolve(requestConfig);\n  // when running on the server, we don't need to proxy the request\n  if (typeof window === \"undefined\") {\n    return passthrough;\n  }\n  // if x-fal-target-url is already set, we skip it\n  return (requestConfig) =>\n    requestConfig.headers && TARGET_URL_HEADER in requestConfig\n      ? passthrough(requestConfig)\n      : Promise.resolve({\n          ...requestConfig,\n          url: config.targetUrl,\n          headers: {\n            ...(requestConfig.headers || {}),\n            [TARGET_URL_HEADER]: requestConfig.url,\n          },\n        });\n}\n", "import { RequiredConfig } from \"./config\";\nimport { Result, ValidationErrorInfo } from \"./types/common\";\n\nexport type ResponseHandler<Output> = (response: Response) => Promise<Output>;\n\nconst REQUEST_ID_HEADER = \"x-fal-request-id\";\n\nexport type ResponseHandlerCreator<Output> = (\n  config: RequiredConfig,\n) => ResponseHandler<Output>;\n\ntype ApiErrorArgs = {\n  message: string;\n  status: number;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  body?: any;\n  requestId?: string;\n};\n\nexport class ApiError<Body> extends Error {\n  public readonly status: number;\n  public readonly body: Body;\n  public readonly requestId: string;\n  constructor({ message, status, body, requestId }: ApiErrorArgs) {\n    super(message);\n    this.name = \"ApiError\";\n    this.status = status;\n    this.body = body;\n    this.requestId = requestId || \"\";\n  }\n}\n\ntype ValidationErrorBody = {\n  detail: ValidationErrorInfo[];\n};\n\nexport class ValidationError extends ApiError<ValidationErrorBody> {\n  constructor(args: ApiErrorArgs) {\n    super(args);\n    this.name = \"ValidationError\";\n  }\n\n  get fieldErrors(): ValidationErrorInfo[] {\n    // NOTE: this is a hack to support both FastAPI/Pydantic errors\n    // and some custom 422 errors that might not be in the Pydantic format.\n    if (typeof this.body.detail === \"string\") {\n      return [\n        {\n          loc: [\"body\"],\n          msg: this.body.detail,\n          type: \"value_error\",\n        },\n      ];\n    }\n    return this.body.detail || [];\n  }\n\n  getFieldErrors(field: string): ValidationErrorInfo[] {\n    return this.fieldErrors.filter(\n      (error) => error.loc[error.loc.length - 1] === field,\n    );\n  }\n}\n\nexport async function defaultResponseHandler<Output>(\n  response: Response,\n): Promise<Output> {\n  const { status, statusText } = response;\n  const contentType = response.headers.get(\"Content-Type\") ?? \"\";\n  const requestId = response.headers.get(REQUEST_ID_HEADER) || undefined;\n  if (!response.ok) {\n    if (contentType.includes(\"application/json\")) {\n      const body = await response.json();\n      const ErrorType = status === 422 ? ValidationError : ApiError;\n      throw new ErrorType({\n        message: body.message || statusText,\n        status,\n        body,\n        requestId,\n      });\n    }\n    throw new ApiError({\n      message: `HTTP ${status}: ${statusText}`,\n      status,\n      requestId,\n    });\n  }\n  if (contentType.includes(\"application/json\")) {\n    return response.json() as Promise<Output>;\n  }\n  if (contentType.includes(\"text/html\")) {\n    return response.text() as Promise<Output>;\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return response.arrayBuffer() as Promise<Output>;\n  }\n  // TODO convert to either number or bool automatically\n  return response.text() as Promise<Output>;\n}\n\nexport async function resultResponseHandler<Output>(\n  response: Response,\n): Promise<Result<Output>> {\n  const data = await defaultResponseHandler<Output>(response);\n  return {\n    data,\n    requestId: response.headers.get(REQUEST_ID_HEADER) || \"\",\n  } satisfies Result<Output>;\n}\n", "export function ensureEndpointIdFormat(id: string): string {\n  const parts = id.split(\"/\");\n  if (parts.length > 1) {\n    return id;\n  }\n  const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];\n  if (appOwner && appId) {\n    return `${appOwner}/${appId}`;\n  }\n  throw new Error(\n    `Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`,\n  );\n}\n\nconst ENDPOINT_NAMESPACES = [\"workflows\", \"comfy\"] as const;\n\ntype EndpointNamespace = (typeof ENDPOINT_NAMESPACES)[number];\n\nexport type EndpointId = {\n  readonly owner: string;\n  readonly alias: string;\n  readonly path?: string;\n  readonly namespace?: EndpointNamespace;\n};\n\nexport function parseEndpointId(id: string): EndpointId {\n  const normalizedId = ensureEndpointIdFormat(id);\n  const parts = normalizedId.split(\"/\");\n  if (ENDPOINT_NAMESPACES.includes(parts[0] as any)) {\n    return {\n      owner: parts[1],\n      alias: parts[2],\n      path: parts.slice(3).join(\"/\") || undefined,\n      namespace: parts[0] as EndpointNamespace,\n    };\n  }\n  return {\n    owner: parts[0],\n    alias: parts[1],\n    path: parts.slice(2).join(\"/\") || undefined,\n  };\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    const { host } = new URL(url);\n    return /(fal\\.(ai|run))$/.test(host);\n  } catch (_) {\n    return false;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number,\n  leading = false,\n): (...funcArgs: Parameters<T>) => ReturnType<T> | void {\n  let lastFunc: NodeJS.Timeout | null;\n  let lastRan: number;\n\n  return (...args: Parameters<T>): ReturnType<T> | void => {\n    if (!lastRan && leading) {\n      func(...args);\n      lastRan = Date.now();\n    } else {\n      if (lastFunc) {\n        clearTimeout(lastFunc);\n      }\n\n      lastFunc = setTimeout(\n        () => {\n          if (Date.now() - lastRan >= limit) {\n            func(...args);\n            lastRan = Date.now();\n          }\n        },\n        limit - (Date.now() - lastRan),\n      );\n    }\n  };\n}\n\nlet isRunningInReact: boolean | undefined;\n\n/**\n * Not really the most optimal way to detect if we're running in React,\n * but the idea here is that we can support multiple rendering engines\n * (starting with React), with all their peculiarities, without having\n * to add a dependency or creating custom integrations (e.g. custom hooks).\n *\n * Yes, a bit of magic to make things works out-of-the-box.\n * @returns `true` if running in React, `false` otherwise.\n */\nexport function isReact() {\n  if (isRunningInReact === undefined) {\n    const stack = new Error().stack;\n    isRunningInReact =\n      !!stack &&\n      (stack.includes(\"node_modules/react-dom/\") ||\n        stack.includes(\"node_modules/next/\"));\n  }\n  return isRunningInReact;\n}\n\n/**\n * Check if a value is a plain object.\n * @param value - The value to check.\n * @returns `true` if the value is a plain object, `false` otherwise.\n */\nexport function isPlainObject(value: any): boolean {\n  return !!value && Object.getPrototypeOf(value) === Object.prototype;\n}\n\n/**\n * Utility function to sleep for a given number of milliseconds\n */\nexport async function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "import { ApiError } from \"./response\";\nimport { sleep } from \"./utils\";\n\nexport type RetryOptions = {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  retryableStatusCodes: number[];\n  enableJitter: boolean;\n};\n\n/**\n * Base retryable status codes for most requests\n */\nexport const DEFAULT_RETRYABLE_STATUS_CODES = [429, 502, 503, 504];\n\nexport const DEFAULT_RETRY_OPTIONS: RetryOptions = {\n  maxRetries: 3,\n  baseDelay: 1000,\n  maxDelay: 30000,\n  backoffMultiplier: 2,\n  retryableStatusCodes: DEFAULT_RETRYABLE_STATUS_CODES,\n  enableJitter: true,\n};\n\n/**\n * Determines if an error is retryable based on the status code\n */\nexport function isRetryableError(\n  error: any,\n  retryableStatusCodes: number[],\n): boolean {\n  return (\n    error instanceof ApiError && retryableStatusCodes.includes(error.status)\n  );\n}\n\n/**\n * Calculates the backoff delay for a given attempt using exponential backoff\n */\nexport function calculateBackoffDelay(\n  attempt: number,\n  baseDelay: number,\n  maxDelay: number,\n  backoffMultiplier: number,\n  enableJitter: boolean,\n): number {\n  const exponentialDelay = Math.min(\n    baseDelay * Math.pow(backoffMultiplier, attempt),\n    maxDelay,\n  );\n\n  if (enableJitter) {\n    // Add Â±25% jitter to prevent thundering herd\n    const jitter = 0.25 * exponentialDelay * (Math.random() * 2 - 1);\n    return Math.max(0, exponentialDelay + jitter);\n  }\n\n  return exponentialDelay;\n}\n\n/**\n * Retry metrics for tracking retry attempts\n */\nexport interface RetryMetrics {\n  totalAttempts: number;\n  totalDelay: number;\n  lastError?: any;\n}\n\n/**\n * Executes an operation with retry logic and returns both result and metrics\n */\nexport async function executeWithRetry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions,\n  onRetry?: (attempt: number, error: any, delay: number) => void,\n): Promise<{ result: T; metrics: RetryMetrics }> {\n  const metrics: RetryMetrics = {\n    totalAttempts: 0,\n    totalDelay: 0,\n  };\n\n  let lastError: any;\n\n  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {\n    metrics.totalAttempts++;\n\n    try {\n      const result = await operation();\n      return { result, metrics };\n    } catch (error) {\n      lastError = error;\n      metrics.lastError = error;\n\n      if (\n        attempt === options.maxRetries ||\n        !isRetryableError(error, options.retryableStatusCodes)\n      ) {\n        throw error;\n      }\n\n      const delay = calculateBackoffDelay(\n        attempt,\n        options.baseDelay,\n        options.maxDelay,\n        options.backoffMultiplier,\n        options.enableJitter,\n      );\n\n      metrics.totalDelay += delay;\n\n      if (onRetry) {\n        onRetry(attempt + 1, error, delay);\n      }\n\n      await sleep(delay);\n    }\n  }\n\n  throw lastError;\n}\n", "{\n  \"name\": \"@fal-ai/client\",\n  \"description\": \"The fal.ai client for JavaScript and TypeScript\",\n  \"version\": \"1.7.2\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/fal-ai/fal-js.git\",\n    \"directory\": \"libs/client\"\n  },\n  \"keywords\": [\n    \"fal\",\n    \"client\",\n    \"ai\",\n    \"ml\",\n    \"typescript\"\n  ],\n  \"exports\": {\n    \".\": \"./src/index.js\",\n    \"./endpoints\": \"./src/types/endpoints.js\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"endpoints\": [\n        \"src/types/endpoints.d.ts\"\n      ]\n    }\n  },\n  \"main\": \"./src/index.js\",\n  \"types\": \"./src/index.d.ts\",\n  \"dependencies\": {\n    \"@msgpack/msgpack\": \"^3.0.0-beta2\",\n    \"eventsource-parser\": \"^1.1.2\",\n    \"robot3\": \"^0.4.1\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"type\": \"commonjs\"\n}\n", "/* eslint-disable @typescript-eslint/no-var-requires */\n\nexport function isBrowser(): boolean {\n  return (\n    typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n  );\n}\n\nlet memoizedUserAgent: string | null = null;\n\nexport function getUserAgent(): string {\n  if (memoizedUserAgent !== null) {\n    return memoizedUserAgent;\n  }\n  const packageInfo = require(\"../package.json\");\n  memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;\n  return memoizedUserAgent;\n}\n", "import {\n  withMiddleware,\n  withProxy,\n  type RequestMiddleware,\n} from \"./middleware\";\nimport type { ResponseHandler } from \"./response\";\nimport { defaultResponseHandler } from \"./response\";\nimport { DEFAULT_RETRY_OPTIONS, type RetryOptions } from \"./retry\";\nimport { isBrowser } from \"./runtime\";\n\nexport type CredentialsResolver = () => string | undefined;\n\ntype FetchType = typeof fetch;\n\nexport function resolveDefaultFetch(): FetchType {\n  if (typeof fetch === \"undefined\") {\n    throw new Error(\n      \"Your environment does not support fetch. Please provide your own fetch implementation.\",\n    );\n  }\n  return fetch;\n}\n\nexport type Config = {\n  /**\n   * The credentials to use for the fal client. When using the\n   * client in the browser, it's recommended to use a proxy server to avoid\n   * exposing the credentials in the client's environment.\n   *\n   * By default it tries to use the `FAL_KEY` environment variable, when\n   * `process.env` is defined.\n   *\n   * @see https://fal.ai/docs/model-endpoints/server-side\n   * @see #suppressLocalCredentialsWarning\n   */\n  credentials?: undefined | string | CredentialsResolver;\n  /**\n   * Suppresses the warning when the fal credentials are exposed in the\n   * browser's environment. Make sure you understand the security implications\n   * before enabling this option.\n   */\n  suppressLocalCredentialsWarning?: boolean;\n  /**\n   * The URL of the proxy server to use for the client requests. The proxy\n   * server should forward the requests to the fal api.\n   */\n  proxyUrl?: string;\n  /**\n   * The request middleware to use for the client requests. By default it\n   * doesn't apply any middleware.\n   */\n  requestMiddleware?: RequestMiddleware;\n  /**\n   * The response handler to use for the client requests. By default it uses\n   * a built-in response handler that returns the JSON response.\n   */\n  responseHandler?: ResponseHandler<any>;\n  /**\n   * The fetch implementation to use for the client requests. By default it uses\n   * the global `fetch` function.\n   */\n  fetch?: FetchType;\n  /**\n   * Retry configuration for handling transient errors like rate limiting and server errors.\n   * When not specified, a default retry configuration is used.\n   */\n  retry?: Partial<RetryOptions>;\n};\n\nexport type RequiredConfig = Required<Config>;\n\n/**\n * Checks if the required FAL environment variables are set.\n *\n * @returns `true` if the required environment variables are set,\n * `false` otherwise.\n */\nfunction hasEnvVariables(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    process.env &&\n    (typeof process.env.FAL_KEY !== \"undefined\" ||\n      (typeof process.env.FAL_KEY_ID !== \"undefined\" &&\n        typeof process.env.FAL_KEY_SECRET !== \"undefined\"))\n  );\n}\n\nexport const credentialsFromEnv: CredentialsResolver = () => {\n  if (!hasEnvVariables()) {\n    return undefined;\n  }\n\n  if (typeof process.env.FAL_KEY !== \"undefined\") {\n    return process.env.FAL_KEY;\n  }\n\n  return process.env.FAL_KEY_ID\n    ? `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}`\n    : undefined;\n};\n\nconst DEFAULT_CONFIG: Partial<Config> = {\n  credentials: credentialsFromEnv,\n  suppressLocalCredentialsWarning: false,\n  requestMiddleware: (request) => Promise.resolve(request),\n  responseHandler: defaultResponseHandler,\n  retry: DEFAULT_RETRY_OPTIONS,\n};\n\n/**\n * Configures the fal client.\n *\n * @param config the new configuration.\n */\nexport function createConfig(config: Config): RequiredConfig {\n  let configuration = {\n    ...DEFAULT_CONFIG,\n    ...config,\n    fetch: config.fetch ?? resolveDefaultFetch(),\n    // Merge retry configuration with defaults\n    retry: {\n      ...DEFAULT_RETRY_OPTIONS,\n      ...(config.retry || {}),\n    },\n  } as RequiredConfig;\n  if (config.proxyUrl) {\n    configuration = {\n      ...configuration,\n      requestMiddleware: withMiddleware(\n        configuration.requestMiddleware,\n        withProxy({ targetUrl: config.proxyUrl }),\n      ),\n    };\n  }\n  const { credentials: resolveCredentials, suppressLocalCredentialsWarning } =\n    configuration;\n  const credentials =\n    typeof resolveCredentials === \"function\"\n      ? resolveCredentials()\n      : resolveCredentials;\n  if (isBrowser() && credentials && !suppressLocalCredentialsWarning) {\n    console.warn(\n      \"The fal credentials are exposed in the browser's environment. \" +\n        \"That's not recommended for production use cases.\",\n    );\n  }\n  return configuration;\n}\n\n/**\n * @returns the URL of the fal REST api endpoint.\n */\nexport function getRestApiUrl(): string {\n  return \"https://rest.alpha.fal.ai\";\n}\n", "import { RequiredConfig } from \"./config\";\nimport { ResponseHandler } from \"./response\";\nimport {\n  calculateBackoffDelay,\n  isRetryableError,\n  type RetryOptions,\n} from \"./retry\";\nimport { getUserAgent, isBrowser } from \"./runtime\";\nimport { RunOptions, UrlOptions } from \"./types/common\";\nimport { ensureEndpointIdFormat, isValidUrl, sleep } from \"./utils\";\n\nconst isCloudflareWorkers =\n  typeof navigator !== \"undefined\" &&\n  navigator?.userAgent === \"Cloudflare-Workers\";\n\ntype RequestOptions = {\n  responseHandler?: ResponseHandler<any>;\n  /**\n   * Retry configuration for this specific request.\n   * If not specified, uses the default retry configuration from the client config.\n   */\n  retry?: Partial<RetryOptions>;\n};\n\ntype RequestParams<Input = any> = {\n  method?: string;\n  targetUrl: string;\n  input?: Input;\n  config: RequiredConfig;\n  options?: RequestOptions & RequestInit;\n  headers?: Record<string, string>;\n};\n\nexport async function dispatchRequest<Input, Output>(\n  params: RequestParams<Input>,\n): Promise<Output> {\n  const { targetUrl, input, config, options = {} } = params;\n  const {\n    credentials: credentialsValue,\n    requestMiddleware,\n    responseHandler,\n    fetch,\n  } = config;\n\n  const retryOptions: RetryOptions = {\n    ...config.retry,\n    ...(options.retry || {}),\n  } as RetryOptions;\n\n  const executeRequest = async (): Promise<Output> => {\n    const userAgent = isBrowser() ? {} : { \"User-Agent\": getUserAgent() };\n    const credentials =\n      typeof credentialsValue === \"function\"\n        ? credentialsValue()\n        : credentialsValue;\n\n    const { method, url, headers } = await requestMiddleware({\n      method: (params.method ?? options.method ?? \"post\").toUpperCase(),\n      url: targetUrl,\n      headers: params.headers,\n    });\n    const authHeader = credentials\n      ? { Authorization: `Key ${credentials}` }\n      : {};\n    const requestHeaders = {\n      ...authHeader,\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      ...userAgent,\n      ...(headers ?? {}),\n    } as HeadersInit;\n\n    const {\n      responseHandler: customResponseHandler,\n      retry: _,\n      ...requestInit\n    } = options;\n    const response = await fetch(url, {\n      ...requestInit,\n      method,\n      headers: {\n        ...requestHeaders,\n        ...(requestInit.headers ?? {}),\n      },\n      ...(!isCloudflareWorkers && { mode: \"cors\" }),\n      signal: options.signal,\n      body:\n        method.toLowerCase() !== \"get\" && input\n          ? JSON.stringify(input)\n          : undefined,\n    });\n    const handleResponse = customResponseHandler ?? responseHandler;\n    return await handleResponse(response);\n  };\n\n  let lastError: any;\n  for (let attempt = 0; attempt <= retryOptions.maxRetries; attempt++) {\n    try {\n      return await executeRequest();\n    } catch (error) {\n      lastError = error;\n\n      const shouldNotRetry =\n        attempt === retryOptions.maxRetries ||\n        !isRetryableError(error, retryOptions.retryableStatusCodes) ||\n        options.signal?.aborted;\n      if (shouldNotRetry) {\n        throw error;\n      }\n\n      const delay = calculateBackoffDelay(\n        attempt,\n        retryOptions.baseDelay,\n        retryOptions.maxDelay,\n        retryOptions.backoffMultiplier,\n        retryOptions.enableJitter,\n      );\n\n      await sleep(delay);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Builds the final url to run the function based on its `id` or alias and\n * a the options from `RunOptions<Input>`.\n *\n * @private\n * @param id the function id or alias\n * @param options the run options\n * @returns the final url to run the function\n */\nexport function buildUrl<Input>(\n  id: string,\n  options: RunOptions<Input> & UrlOptions = {},\n): string {\n  const method = (options.method ?? \"post\").toLowerCase();\n  const path = (options.path ?? \"\").replace(/^\\//, \"\").replace(/\\/{2,}/, \"/\");\n  const input = options.input;\n  const params = {\n    ...(options.query || {}),\n    ...(method === \"get\" ? input : {}),\n  };\n\n  const queryParams =\n    Object.keys(params).length > 0\n      ? `?${new URLSearchParams(params).toString()}`\n      : \"\";\n\n  // if a fal url is passed, just use it\n  if (isValidUrl(id)) {\n    const url = id.endsWith(\"/\") ? id : `${id}/`;\n    return `${url}${path}${queryParams}`;\n  }\n\n  const appId = ensureEndpointIdFormat(id);\n  const subdomain = options.subdomain ? `${options.subdomain}.` : \"\";\n  const url = `https://${subdomain}fal.run/${appId}/${path}`;\n  return `${url.replace(/\\/$/, \"\")}${queryParams}`;\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number,\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n", "import { getRestApiUrl, RequiredConfig } from \"./config\";\nimport { dispatchRequest } from \"./request\";\nimport { parseEndpointId } from \"./utils\";\n\nexport const TOKEN_EXPIRATION_SECONDS = 120;\n\n/**\n * Get a token to connect to the realtime endpoint.\n */\nexport async function getTemporaryAuthToken(\n  app: string,\n  config: RequiredConfig,\n): Promise<string> {\n  const appId = parseEndpointId(app);\n  const token: string | object = await dispatchRequest<any, string>({\n    method: \"POST\",\n    targetUrl: `${getRestApiUrl()}/tokens/`,\n    config,\n    input: {\n      allowed_apps: [appId.alias],\n      token_expiration: TOKEN_EXPIRATION_SECONDS,\n    },\n  });\n  // keep this in case the response was wrapped (old versions of the proxy do that)\n  // should be safe to remove in the future\n  if (typeof token !== \"string\" && token[\"detail\"]) {\n    return token[\"detail\"];\n  }\n  return token;\n}\n", "import { createParser } from \"eventsource-parser\";\nimport { getTemporaryAuthToken } from \"./auth\";\nimport { RequiredConfig } from \"./config\";\nimport { buildUrl, dispatchRequest } from \"./request\";\nimport { ApiError, defaultResponseHandler } from \"./response\";\nimport { type StorageClient } from \"./storage\";\nimport { EndpointType, InputType, OutputType } from \"./types/client\";\n\nexport type StreamingConnectionMode = \"client\" | \"server\";\n\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\n\n/**\n * The stream API options. It requires the API input and also\n * offers configuration options.\n */\nexport type StreamOptions<Input> = {\n  /**\n   * The endpoint URL. If not provided, it will be generated from the\n   * `endpointId` and the `queryParams`.\n   */\n  readonly url?: string;\n\n  /**\n   * The API input payload.\n   */\n  readonly input?: Input;\n\n  /**\n   * The query parameters to be sent with the request.\n   */\n  readonly queryParams?: Record<string, string>;\n\n  /**\n   * The maximum time interval in milliseconds between stream chunks. Defaults to 15s.\n   */\n  readonly timeout?: number;\n\n  /**\n   * Whether it should auto-upload File-like types to fal's storage\n   * or not.\n   */\n  readonly autoUpload?: boolean;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: \"get\" | \"post\" | \"put\" | \"delete\" | string;\n\n  /**\n   * The content type the client accepts as response.\n   * By default this is set to `text/event-stream`.\n   */\n  readonly accept?: string;\n\n  /**\n   * The streaming connection mode. This is used to determine\n   * whether the streaming will be done from the browser itself (client)\n   * or through your own server, either when running on NodeJS or when\n   * using a proxy that supports streaming.\n   *\n   * It defaults to `server`. Set to `client` if your server proxy doesn't\n   * support streaming.\n   */\n  readonly connectionMode?: StreamingConnectionMode;\n\n  /**\n   * The signal to abort the request.\n   */\n  readonly signal?: AbortSignal;\n};\n\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n\ntype FalStreamEventType = \"data\" | \"error\" | \"done\";\n\ntype EventHandler<T = any> = (event: T) => void;\n\n/**\n * The class representing a streaming response. With t\n */\nexport class FalStream<Input, Output> {\n  // properties\n  config: RequiredConfig;\n  endpointId: string;\n  url: string;\n  options: StreamOptions<Input>;\n\n  // support for event listeners\n  private listeners: Map<FalStreamEventType, EventHandler[]> = new Map();\n  private buffer: Output[] = [];\n\n  // local state\n  private currentData: Output | undefined = undefined;\n  private lastEventTimestamp = 0;\n  private streamClosed = false;\n  private _requestId: string | null = null;\n  private donePromise: Promise<Output>;\n\n  private abortController = new AbortController();\n\n  constructor(\n    endpointId: string,\n    config: RequiredConfig,\n    options: StreamOptions<Input>,\n  ) {\n    this.endpointId = endpointId;\n    this.config = config;\n    this.url =\n      options.url ??\n      buildUrl(endpointId, {\n        path: \"/stream\",\n        query: options.queryParams,\n      });\n    this.options = options;\n    this.donePromise = new Promise<Output>((resolve, reject) => {\n      if (this.streamClosed) {\n        reject(\n          new ApiError({\n            message: \"Streaming connection is already closed.\",\n            status: 400,\n            body: undefined,\n            requestId: this._requestId || undefined,\n          }),\n        );\n      }\n      this.signal.addEventListener(\"abort\", () => {\n        resolve(this.currentData ?? ({} as Output));\n      });\n      this.on(\"done\", (data) => {\n        this.streamClosed = true;\n        resolve(data);\n      });\n      this.on(\"error\", (error) => {\n        this.streamClosed = true;\n        reject(error);\n      });\n    });\n    // if a abort signal was passed, sync it with the internal one\n    if (options.signal) {\n      options.signal.addEventListener(\"abort\", () => {\n        this.abortController.abort();\n      });\n    }\n\n    // start the streaming request\n    this.start().catch(this.handleError);\n  }\n\n  private start = async () => {\n    const { endpointId, options } = this;\n    const { input, method = \"post\", connectionMode = \"server\" } = options;\n    try {\n      if (connectionMode === \"client\") {\n        // if we are in the browser, we need to get a temporary token\n        // to authenticate the request\n        const token = await getTemporaryAuthToken(endpointId, this.config);\n        const { fetch } = this.config;\n        const parsedUrl = new URL(this.url);\n        parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n        const response = await fetch(parsedUrl.toString(), {\n          method: method.toUpperCase(),\n          headers: {\n            accept: options.accept ?? CONTENT_TYPE_EVENT_STREAM,\n            \"content-type\": \"application/json\",\n          },\n          body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n          signal: this.abortController.signal,\n        });\n        this._requestId = response.headers.get(\"x-fal-request-id\");\n        return await this.handleResponse(response);\n      }\n      return await dispatchRequest({\n        method: method.toUpperCase(),\n        targetUrl: this.url,\n        input,\n        config: this.config,\n        options: {\n          headers: {\n            accept: options.accept ?? CONTENT_TYPE_EVENT_STREAM,\n          },\n          responseHandler: async (response) => {\n            this._requestId = response.headers.get(\"x-fal-request-id\");\n            return await this.handleResponse(response);\n          },\n          signal: this.abortController.signal,\n        },\n      });\n    } catch (error) {\n      this.handleError(error);\n    }\n  };\n\n  private handleResponse = async (response: Response) => {\n    if (!response.ok) {\n      try {\n        // we know the response failed, call the response handler\n        // so the exception gets converted to ApiError correctly\n        await defaultResponseHandler(response);\n      } catch (error) {\n        this.emit(\"error\", error);\n      }\n      return;\n    }\n\n    const body = response.body;\n    if (!body) {\n      this.emit(\n        \"error\",\n        new ApiError({\n          message: \"Response body is empty.\",\n          status: 400,\n          body: undefined,\n          requestId: this._requestId || undefined,\n        }),\n      );\n      return;\n    }\n\n    const isEventStream = (\n      response.headers.get(\"content-type\") ?? \"\"\n    ).startsWith(CONTENT_TYPE_EVENT_STREAM);\n    // any response that is not a text/event-stream will be handled as a binary stream\n    if (!isEventStream) {\n      const reader = body.getReader();\n      const emitRawChunk = () => {\n        reader.read().then(({ done, value }) => {\n          if (done) {\n            this.emit(\"done\", this.currentData);\n            return;\n          }\n          this.currentData = value as Output;\n          this.emit(\"data\", value);\n          emitRawChunk();\n        });\n      };\n      emitRawChunk();\n      return;\n    }\n\n    const decoder = new TextDecoder(\"utf-8\");\n    const reader = response.body.getReader();\n\n    const parser = createParser((event) => {\n      if (event.type === \"event\") {\n        const data = event.data;\n\n        try {\n          const parsedData = JSON.parse(data);\n          this.buffer.push(parsedData);\n          this.currentData = parsedData;\n          this.emit(\"data\", parsedData);\n\n          // also emit 'message'for backwards compatibility\n          this.emit(\"message\" as any, parsedData);\n        } catch (e) {\n          this.emit(\"error\", e);\n        }\n      }\n    });\n\n    const timeout = this.options.timeout ?? EVENT_STREAM_TIMEOUT;\n\n    const readPartialResponse = async () => {\n      const { value, done } = await reader.read();\n      this.lastEventTimestamp = Date.now();\n\n      parser.feed(decoder.decode(value));\n\n      if (Date.now() - this.lastEventTimestamp > timeout) {\n        this.emit(\n          \"error\",\n          new ApiError({\n            message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n            status: 408,\n            requestId: this._requestId || undefined,\n          }),\n        );\n      }\n\n      if (!done) {\n        readPartialResponse().catch(this.handleError);\n      } else {\n        this.emit(\"done\", this.currentData);\n      }\n    };\n\n    readPartialResponse().catch(this.handleError);\n    return;\n  };\n\n  private handleError = (error: any) => {\n    // In case AbortError is thrown but the signal is marked as aborted\n    // it means the user called abort() and we should not emit an error\n    // as it's expected behavior\n    // See note on: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\n    if (error.name === \"AbortError\" || this.signal.aborted) {\n      return;\n    }\n    const apiError =\n      error instanceof ApiError\n        ? error\n        : new ApiError({\n            message: error.message ?? \"An unknown error occurred\",\n            status: 500,\n            requestId: this._requestId || undefined,\n          });\n    this.emit(\"error\", apiError);\n    return;\n  };\n\n  public on = (type: FalStreamEventType, listener: EventHandler) => {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, []);\n    }\n    this.listeners.get(type)?.push(listener);\n  };\n\n  private emit = (type: FalStreamEventType, event: any) => {\n    const listeners = this.listeners.get(type) || [];\n    for (const listener of listeners) {\n      listener(event);\n    }\n  };\n\n  async *[Symbol.asyncIterator]() {\n    let running = true;\n    const stopAsyncIterator = () => (running = false);\n    this.on(\"error\", stopAsyncIterator);\n    this.on(\"done\", stopAsyncIterator);\n    while (running || this.buffer.length > 0) {\n      const data = this.buffer.shift();\n      if (data) {\n        yield data;\n      }\n\n      // the short timeout ensures the while loop doesn't block other\n      // frames getting executed concurrently\n      await new Promise((resolve) => setTimeout(resolve, 16));\n    }\n  }\n\n  /**\n   * Gets a reference to the `Promise` that indicates whether the streaming\n   * is done or not. Developers should always call this in their apps to ensure\n   * the request is over.\n   *\n   * An alternative to this, is to use `on('done')` in case your application\n   * architecture works best with event listeners.\n   *\n   * @returns the promise that resolves when the request is done.\n   */\n  public done = async () => this.donePromise;\n\n  /**\n   * Aborts the streaming request.\n   *\n   * **Note:** This method is noop in case the request is already done.\n   *\n   * @param reason optional cause for aborting the request.\n   */\n  public abort = (reason?: string | Error) => {\n    if (!this.streamClosed) {\n      this.abortController.abort(reason);\n    }\n  };\n\n  /**\n   * Gets the `AbortSignal` instance that can be used to listen for abort events.\n   *\n   * **Note:** this signal is internal to the `FalStream` instance. If you pass your\n   * own abort signal, the `FalStream` will listen to it and abort it appropriately.\n   *\n   * @returns the `AbortSignal` instance.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n   */\n  public get signal() {\n    return this.abortController.signal;\n  }\n\n  /**\n   * Gets the request id of the streaming request.\n   *\n   * @returns the request id.\n   */\n  public get requestId() {\n    return this._requestId;\n  }\n}\n\n/**\n * The streaming client interface.\n */\nexport interface StreamingClient {\n  /**\n   * Calls a fal app that supports streaming and provides a streaming-capable\n   * object as a result, that can be used to get partial results through either\n   * `AsyncIterator` or through an event listener.\n   *\n   * @param endpointId the endpoint id, e.g. `fal-ai/llavav15-13b`.\n   * @param options the request options, including the input payload.\n   * @returns the `FalStream` instance.\n   */\n  stream<Id extends EndpointType>(\n    endpointId: Id,\n    options: StreamOptions<InputType<Id>>,\n  ): Promise<FalStream<InputType<Id>, OutputType<Id>>>;\n}\n\ntype StreamingClientDependencies = {\n  config: RequiredConfig;\n  storage: StorageClient;\n};\n\nexport function createStreamingClient({\n  config,\n  storage,\n}: StreamingClientDependencies): StreamingClient {\n  return {\n    async stream<Id extends EndpointType>(\n      endpointId: Id,\n      options: StreamOptions<InputType<Id>>,\n    ) {\n      const input = options.input\n        ? await storage.transformInput(options.input)\n        : undefined;\n      return new FalStream<InputType<Id>, OutputType<Id>>(endpointId, config, {\n        ...options,\n        input: input as InputType<Id>,\n      });\n    },\n  };\n}\n", "import { RequiredConfig } from \"./config\";\nimport { buildUrl, dispatchRequest } from \"./request\";\nimport { resultResponseHandler } from \"./response\";\nimport { DEFAULT_RETRYABLE_STATUS_CODES, RetryOptions } from \"./retry\";\nimport { StorageClient } from \"./storage\";\nimport { FalStream, StreamingConnectionMode } from \"./streaming\";\nimport { EndpointType, InputType, OutputType } from \"./types/client\";\nimport {\n  CompletedQueueStatus,\n  InQueueQueueStatus,\n  QueueStatus,\n  RequestLog,\n  Result,\n  RunOptions,\n} from \"./types/common\";\nimport { parseEndpointId } from \"./utils\";\n\nexport type QueuePriority = \"low\" | \"normal\";\nexport type QueueStatusSubscriptionOptions = QueueStatusOptions &\n  QueueModeOptions &\n  Omit<QueueCommonSubscribeOptions, \"onEnqueue\" | \"webhookUrl\">;\n\ntype TimeoutId = ReturnType<typeof setTimeout> | undefined;\n\nconst DEFAULT_POLL_INTERVAL = 500;\n\ntype QueueModeOptions =\n  | {\n      mode?: \"polling\";\n      /**\n       * The interval (in milliseconds) at which to poll for updates.\n       * If not provided, a default value of `500` will be used.\n       *\n       * This value is ignored if `mode` is set to `streaming`.\n       */\n      pollInterval?: number;\n    }\n  | {\n      mode: \"streaming\";\n\n      /**\n       * The connection mode to use for streaming updates. It defaults to `server`.\n       * Set to `client` if your server proxy doesn't support streaming.\n       */\n      connectionMode?: StreamingConnectionMode;\n    };\n\ntype QueueCommonSubscribeOptions = {\n  /**\n   * The mode to use for subscribing to updates. It defaults to `polling`.\n   * You can also use client-side streaming by setting it to `streaming`.\n   *\n   * **Note:** Streaming is currently experimental and once stable, it will\n   * be the default mode.\n   *\n   * @see pollInterval\n   */\n  mode?: \"polling\" | \"streaming\";\n\n  /**\n   * Callback function that is called when a request is enqueued.\n   * @param requestId - The unique identifier for the enqueued request.\n   */\n  onEnqueue?: (requestId: string) => void;\n\n  /**\n   * Callback function that is called when the status of the queue changes.\n   * @param status - The current status of the queue.\n   */\n  onQueueUpdate?: (status: QueueStatus) => void;\n\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n\n  /**\n   * The timeout (in milliseconds) for the request. If the request is not\n   * completed within this time, the subscription will be cancelled.\n   *\n   * Keep in mind that although the client resolves the function on a timeout,\n   * and will try to cancel the request on the server, the server might not be\n   * able to cancel the request if it's already running.\n   *\n   * Note: currently, the timeout is not enforced and the default is `undefined`.\n   * This behavior might change in the future.\n   */\n  timeout?: number;\n\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n\n  /**\n   * The priority of the request. It defaults to `normal`.\n   * @see QueuePriority\n   */\n  priority?: QueuePriority;\n};\n\n/**\n * Options for subscribing to the request queue.\n */\nexport type QueueSubscribeOptions = QueueCommonSubscribeOptions &\n  QueueModeOptions;\n\n/**\n * Options for submitting a request to the queue.\n */\nexport type SubmitOptions<Input> = RunOptions<Input> & {\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n\n  /**\n   * The priority of the request. It defaults to `normal`.\n   * @see QueuePriority\n   */\n  priority?: QueuePriority;\n\n  /**\n   * A hint for the runner to use when processing the request.\n   * This will be sent as the `X-Fal-Runner-Hint` header.\n   */\n  hint?: string;\n};\n\ntype BaseQueueOptions = {\n  /**\n   * The unique identifier for the enqueued request.\n   */\n  requestId: string;\n\n  /**\n   * The signal to abort the request.\n   */\n  abortSignal?: AbortSignal;\n};\n\nexport type QueueStatusOptions = BaseQueueOptions & {\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n};\n\nexport type QueueStatusStreamOptions = QueueStatusOptions & {\n  /**\n   * The connection mode to use for streaming updates. It defaults to `server`.\n   * Set to `client` if your server proxy doesn't support streaming.\n   */\n  connectionMode?: StreamingConnectionMode;\n};\n\n// Queue operations benefit from more aggressive retry policies\nconst QUEUE_RETRY_CONFIG: Partial<RetryOptions> = {\n  maxRetries: 3,\n  baseDelay: 1000,\n  maxDelay: 60000,\n  retryableStatusCodes: DEFAULT_RETRYABLE_STATUS_CODES,\n};\n\n// Status checking can be retried more aggressively since it's read-only\nconst QUEUE_STATUS_RETRY_CONFIG: Partial<RetryOptions> = {\n  maxRetries: 5,\n  baseDelay: 1000,\n  maxDelay: 30000,\n  retryableStatusCodes: [...DEFAULT_RETRYABLE_STATUS_CODES, 500],\n};\n\n/**\n * Represents a request queue with methods for submitting requests,\n * checking their status, retrieving results, and subscribing to updates.\n */\nexport interface QueueClient {\n  /**\n   * Submits a request to the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of enqueuing the request.\n   */\n  submit<Id extends EndpointType>(\n    endpointId: Id,\n    options: SubmitOptions<InputType<Id>>,\n  ): Promise<InQueueQueueStatus>;\n\n  /**\n   * Retrieves the status of a specific request in the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the status of the request.\n   */\n  status(endpointId: string, options: QueueStatusOptions): Promise<QueueStatus>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue using HTTP streaming events.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns The streaming object that can be used to listen for updates.\n   */\n  streamStatus(\n    endpointId: string,\n    options: QueueStatusStreamOptions,\n  ): Promise<FalStream<unknown, QueueStatus>>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue using polling or streaming.\n   * See `options.mode` for more details.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns A promise that resolves to the final status of the request.\n   */\n  subscribeToStatus(\n    endpointId: string,\n    options: QueueStatusSubscriptionOptions,\n  ): Promise<CompletedQueueStatus>;\n\n  /**\n   * Retrieves the result of a specific request from the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of the request.\n   */\n  result<Id extends EndpointType>(\n    endpointId: Id,\n    options: BaseQueueOptions,\n  ): Promise<Result<OutputType<Id>>>;\n\n  /**\n   * Cancels a request in the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request\n   * is run and how updates are received.\n   * @returns A promise that resolves once the request is cancelled.\n   * @throws {Error} If the request cannot be cancelled.\n   */\n  cancel(endpointId: string, options: BaseQueueOptions): Promise<void>;\n}\n\ntype QueueClientDependencies = {\n  config: RequiredConfig;\n  storage: StorageClient;\n};\n\nexport const createQueueClient = ({\n  config,\n  storage,\n}: QueueClientDependencies): QueueClient => {\n  const ref: QueueClient = {\n    async submit<Input>(\n      endpointId: string,\n      options: SubmitOptions<Input>,\n    ): Promise<InQueueQueueStatus> {\n      const { webhookUrl, priority, hint, ...runOptions } = options;\n      const input = options.input\n        ? await storage.transformInput(options.input)\n        : undefined;\n      return dispatchRequest<Input, InQueueQueueStatus>({\n        method: options.method,\n        targetUrl: buildUrl(endpointId, {\n          ...runOptions,\n          subdomain: \"queue\",\n          query: webhookUrl ? { fal_webhook: webhookUrl } : undefined,\n        }),\n        headers: {\n          \"x-fal-queue-priority\": priority ?? \"normal\",\n          ...(hint && { \"x-fal-runner-hint\": hint }),\n        },\n        input: input as Input,\n        config,\n        options: {\n          signal: options.abortSignal,\n          retry: QUEUE_RETRY_CONFIG,\n        },\n      });\n    },\n    async status(\n      endpointId: string,\n      { requestId, logs = false, abortSignal }: QueueStatusOptions,\n    ): Promise<QueueStatus> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n      return dispatchRequest<unknown, QueueStatus>({\n        method: \"get\",\n        targetUrl: buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          query: { logs: logs ? \"1\" : \"0\" },\n          path: `/requests/${requestId}/status`,\n        }),\n        config,\n        options: {\n          signal: abortSignal,\n          retry: QUEUE_STATUS_RETRY_CONFIG,\n        },\n      });\n    },\n\n    async streamStatus(\n      endpointId: string,\n      { requestId, logs = false, connectionMode }: QueueStatusStreamOptions,\n    ): Promise<FalStream<unknown, QueueStatus>> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n\n      const queryParams = {\n        logs: logs ? \"1\" : \"0\",\n      };\n\n      const url = buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n        subdomain: \"queue\",\n        path: `/requests/${requestId}/status/stream`,\n        query: queryParams,\n      });\n\n      return new FalStream<unknown, QueueStatus>(endpointId, config, {\n        url,\n        method: \"get\",\n        connectionMode,\n        queryParams,\n      });\n    },\n\n    async subscribeToStatus(\n      endpointId,\n      options,\n    ): Promise<CompletedQueueStatus> {\n      const requestId = options.requestId;\n      const timeout = options.timeout;\n      let timeoutId: TimeoutId = undefined;\n\n      const handleCancelError = () => {\n        // Ignore errors as the client will follow through with the timeout\n        // regardless of the server response. In case cancelation fails, we\n        // still want to reject the promise and consider the client call canceled.\n      };\n      if (options.mode === \"streaming\") {\n        const status = await ref.streamStatus(endpointId, {\n          requestId,\n          logs: options.logs,\n          connectionMode:\n            \"connectionMode\" in options\n              ? (options.connectionMode as StreamingConnectionMode)\n              : undefined,\n        });\n        const logs: RequestLog[] = [];\n        if (timeout) {\n          timeoutId = setTimeout(() => {\n            status.abort();\n            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n            // TODO this error cannot bubble up to the user since it's thrown in\n            // a closure in the global scope due to setTimeout behavior.\n            // User will get a platform error instead. We should find a way to\n            // make this behavior aligned with polling.\n            throw new Error(\n              `Client timed out waiting for the request to complete after ${timeout}ms`,\n            );\n          }, timeout);\n        }\n        status.on(\"data\", (data: QueueStatus) => {\n          if (options.onQueueUpdate) {\n            // accumulate logs to match previous polling behavior\n            if (\n              \"logs\" in data &&\n              Array.isArray(data.logs) &&\n              data.logs.length > 0\n            ) {\n              logs.push(...data.logs);\n            }\n            options.onQueueUpdate(\"logs\" in data ? { ...data, logs } : data);\n          }\n        });\n        const doneStatus = await status.done();\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        return doneStatus as CompletedQueueStatus;\n      }\n      // default to polling until status streaming is stable and faster\n      return new Promise<CompletedQueueStatus>((resolve, reject) => {\n        let pollingTimeoutId: TimeoutId;\n        // type resolution isn't great in this case, so check for its presence\n        // and and type so the typechecker behaves as expected\n        const pollInterval =\n          \"pollInterval\" in options && typeof options.pollInterval === \"number\"\n            ? (options.pollInterval ?? DEFAULT_POLL_INTERVAL)\n            : DEFAULT_POLL_INTERVAL;\n\n        const clearScheduledTasks = () => {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          if (pollingTimeoutId) {\n            clearTimeout(pollingTimeoutId);\n          }\n        };\n        if (timeout) {\n          timeoutId = setTimeout(() => {\n            clearScheduledTasks();\n            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n            reject(\n              new Error(\n                `Client timed out waiting for the request to complete after ${timeout}ms`,\n              ),\n            );\n          }, timeout);\n        }\n        const poll = async () => {\n          try {\n            const requestStatus = await ref.status(endpointId, {\n              requestId,\n              logs: options.logs ?? false,\n              abortSignal: options.abortSignal,\n            });\n            if (options.onQueueUpdate) {\n              options.onQueueUpdate(requestStatus);\n            }\n            if (requestStatus.status === \"COMPLETED\") {\n              clearScheduledTasks();\n              resolve(requestStatus);\n              return;\n            }\n            pollingTimeoutId = setTimeout(poll, pollInterval);\n          } catch (error) {\n            clearScheduledTasks();\n            reject(error);\n          }\n        };\n        poll().catch(reject);\n      });\n    },\n\n    async result<Output>(\n      endpointId: string,\n      { requestId, abortSignal }: BaseQueueOptions,\n    ): Promise<Result<Output>> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n      return dispatchRequest<unknown, Result<Output>>({\n        method: \"get\",\n        targetUrl: buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          path: `/requests/${requestId}`,\n        }),\n        config: {\n          ...config,\n          responseHandler: resultResponseHandler,\n        },\n        options: {\n          signal: abortSignal,\n          retry: QUEUE_RETRY_CONFIG,\n        },\n      });\n    },\n\n    async cancel(\n      endpointId: string,\n      { requestId, abortSignal }: BaseQueueOptions,\n    ): Promise<void> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n      await dispatchRequest<unknown, void>({\n        method: \"put\",\n        targetUrl: buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          path: `/requests/${requestId}/cancel`,\n        }),\n        config,\n        options: {\n          signal: abortSignal,\n        },\n      });\n    },\n  };\n  return ref;\n};\n", "export function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\n\nconst sharedTextEncoder = new TextEncoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\n\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = new TextDecoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\n\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}\n", "/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  readonly type: number;\n  readonly data: Uint8Array | ((pos: number) => Uint8Array);\n\n  constructor(type: number, data: Uint8Array | ((pos: number) => Uint8Array)) {\n    this.type = type;\n    this.data = data;\n  }\n}\n", "export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n", "// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number): number {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n", "// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError.ts\";\nimport { getInt64, setInt64 } from \"./utils/int.ts\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n", "// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData.ts\";\nimport { timestampExtension } from \"./timestamp.ts\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (\n  input: unknown,\n  context: ContextType,\n) => Uint8Array | ((dataPos: number) => Uint8Array) | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = -1 - type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n", "function isArrayBufferLike(buffer: unknown): buffer is ArrayBufferLike {\n  return (\n    buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \"undefined\" && buffer instanceof SharedArrayBuffer)\n  );\n}\n\nexport function ensureUint8Array(\n  buffer: ArrayLike<number> | Uint8Array<ArrayBufferLike> | ArrayBufferView | ArrayBufferLike,\n): Uint8Array<ArrayBufferLike> {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (isArrayBufferLike(buffer)) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n", "import { utf8Count, utf8Encode } from \"./utils/utf8.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { setInt64, setUint64 } from \"./utils/int.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport type { ExtData } from \"./ExtData.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport type EncoderOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Encodes bigint as Int64 or Uint64 if it's set to true.\n     * {@link forceIntegerToFloat} does not affect bigint.\n     * Depends on ES2020's {@link DataView#setBigInt64} and\n     * {@link DataView#setBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport class Encoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly maxDepth: number;\n  private readonly initialBufferSize: number;\n  private readonly sortKeys: boolean;\n  private readonly forceFloat32: boolean;\n  private readonly ignoreUndefined: boolean;\n  private readonly forceIntegerToFloat: boolean;\n\n  private pos: number;\n  private view: DataView;\n  private bytes: Uint8Array;\n\n  private entered = false;\n\n  public constructor(options?: EncoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n\n  private clone() {\n    // Because of slightly special argument `context`,\n    // type assertion is needed.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Encoder<ContextType>({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      maxDepth: this.maxDepth,\n      initialBufferSize: this.initialBufferSize,\n      sortKeys: this.sortKeys,\n      forceFloat32: this.forceFloat32,\n      ignoreUndefined: this.ignoreUndefined,\n      forceIntegerToFloat: this.forceIntegerToFloat,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encodeSharedRef(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.subarray(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encode(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.slice(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      if (!this.forceIntegerToFloat) {\n        this.encodeNumber(object);\n      } else {\n        this.encodeNumberAsFloat(object);\n      }\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\n      this.encodeBigInt64(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number): void {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else if (!this.useBigInt64) {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else if (!this.useBigInt64) {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n\n  private encodeNumberAsFloat(object: number): void {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n\n  private encodeBigInt64(object: bigint): void {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    if (typeof ext.data === \"function\") {\n      const data = ext.data(this.pos + 6);\n      const size = data.length;\n\n      if (size >= 0x100000000) {\n        throw new Error(`Too large extension object: ${size}`);\n      }\n\n      this.writeU8(0xc9);\n      this.writeU32(size);\n      this.writeI8(ext.type);\n      this.writeU8a(data);\n      return;\n    }\n\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigUint64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigInt64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}\n", "import { Encoder } from \"./Encoder.ts\";\nimport type { EncoderOptions } from \"./Encoder.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options?: EncoderOptions<SplitUndefined<ContextType>>,\n): Uint8Array {\n  const encoder = new Encoder(options);\n  return encoder.encodeSharedRef(value);\n}\n", "export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n", "import { utf8DecodeJs } from \"./utils/utf8.ts\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n  readonly maxKeyLength: number;\n  readonly maxLengthPerKey: number;\n\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n", "import { prettyByte } from \"./utils/prettyByte.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.ts\";\nimport { utf8Decode } from \"./utils/utf8.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.ts\";\nimport { DecodeError } from \"./DecodeError.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\nimport type { KeyDecoder } from \"./CachedKeyDecoder.ts\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * By default, string values will be decoded as UTF-8 strings. However, if this option is true,\n     * string values will be returned as Uint8Arrays without additional decoding.\n     *\n     * This is useful if the strings may contain invalid UTF-8 sequences.\n     *\n     * Note that this option only applies to string values, not map keys. Additionally, when\n     * enabled, raw string length is limited by the maxBinLength option.\n     */\n    rawStrings: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n\n    /**\n     * A function to convert decoded map key to a valid JS key type.\n     *\n     * Defaults to a function that throws an error if the key is not a string or a number.\n     */\n    mapKeyConverter: (key: unknown) => MapKeyType;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst mapKeyConverter = (key: unknown): MapKeyType => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\nclass StackPool {\n  private readonly stack: Array<StackState> = [];\n  private stackHeadPosition = -1;\n\n  public get length(): number {\n    return this.stackHeadPosition + 1;\n  }\n\n  public top(): StackState | undefined {\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public pushArrayState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\n\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n\n  public pushMapState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackMapState;\n\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n\n  private getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState: Partial<StackState> = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null,\n      };\n\n      this.stack.push(partialState as StackState);\n    }\n\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public release(state: StackState): void {\n    const topStackState = this.stack[this.stackHeadPosition];\n\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n\n    if (state.type === STATE_ARRAY) {\n      const partialState = state as Partial<StackArrayState>;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state as Partial<StackMapState>;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n\n    this.stackHeadPosition--;\n  }\n\n  public reset(): void {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView<ArrayBufferLike>(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array<ArrayBufferLike>(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\n    );\n  }\n}\n\nconst MORE_DATA = new RangeError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly rawStrings: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n  private readonly mapKeyConverter: (key: unknown) => MapKeyType;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack = new StackPool();\n\n  private entered = false;\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.rawStrings = options?.rawStrings ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n  }\n\n  private clone(): Decoder<ContextType> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): unknown {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): Generator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): Promise<unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n\n    try {\n      this.entered = true;\n\n      let decoded = false;\n      let object: unknown;\n      for await (const buffer of stream) {\n        if (decoded) {\n          this.entered = false;\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        try {\n          object = this.doDecodeSync();\n          decoded = true;\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n\n      const { headByte, pos, totalPos } = this;\n      throw new RangeError(\n        `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n      );\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>, isArray: boolean): AsyncGenerator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMultiAsync(stream, isArray);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      let isArrayHeaderRequired = isArray;\n      let arrayItemsLeft = -1;\n\n      for await (const buffer of stream) {\n        if (isArray && arrayItemsLeft === 0) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        if (isArrayHeaderRequired) {\n          arrayItemsLeft = this.readArraySize();\n          isArrayHeaderRequired = false;\n          this.complete();\n        }\n\n        try {\n          while (true) {\n            yield this.doDecodeSync();\n            if (--arrayItemsLeft === 0) {\n              break;\n            }\n          }\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top()!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.pushMapState(size);\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.pushArrayState(size);\n  }\n\n  private decodeString(byteLength: number, headerOffset: number): string | Uint8Array {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack.top()!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readU64AsBigInt(): bigint {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64AsBigInt(): bigint {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n", "import { Decoder } from \"./Decoder.ts\";\nimport type { DecoderOptions } from \"./Decoder.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): unknown {\n  const decoder = new Decoder(options);\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(options);\n  return decoder.decodeMulti(buffer);\n}\n", "// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n", "import { Decoder } from \"./Decoder.ts\";\nimport { ensureAsyncIterable } from \"./utils/stream.ts\";\nimport type { DecoderOptions } from \"./Decoder.ts\";\nimport type { ReadableStreamLike } from \"./utils/stream.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport async function decodeAsync<ContextType = undefined>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Promise<unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeAsync(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeArrayStream(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeStream(stream);\n}\n", "// Main Functions:\n\nimport { encode } from \"./encode.ts\";\nexport { encode };\n\nimport { decode, decodeMulti } from \"./decode.ts\";\nexport { decode, decodeMulti };\n\nimport { decodeAsync, decodeArrayStream, decodeMultiStream } from \"./decodeAsync.ts\";\nexport { decodeAsync, decodeArrayStream, decodeMultiStream };\n\nimport { Decoder } from \"./Decoder.ts\";\nexport { Decoder };\nimport type { DecoderOptions } from \"./Decoder.ts\";\nexport type { DecoderOptions };\nimport { DecodeError } from \"./DecodeError.ts\";\nexport { DecodeError };\n\nimport { Encoder } from \"./Encoder.ts\";\nexport { Encoder };\nimport type { EncoderOptions } from \"./Encoder.ts\";\nexport type { EncoderOptions };\n\n// Utilities for Extension Types:\n\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nexport { ExtensionCodec };\nimport type { ExtensionCodecType, ExtensionDecoderType, ExtensionEncoderType } from \"./ExtensionCodec.ts\";\nexport type { ExtensionCodecType, ExtensionDecoderType, ExtensionEncoderType };\nimport { ExtData } from \"./ExtData.ts\";\nexport { ExtData };\n\nimport {\n  EXT_TIMESTAMP,\n  encodeDateToTimeSpec,\n  encodeTimeSpecToTimestamp,\n  decodeTimestampToTimeSpec,\n  encodeTimestampExtension,\n  decodeTimestampExtension,\n} from \"./timestamp.ts\";\nexport {\n  EXT_TIMESTAMP,\n  encodeDateToTimeSpec,\n  encodeTimeSpecToTimestamp,\n  decodeTimestampToTimeSpec,\n  encodeTimestampExtension,\n  decodeTimestampExtension,\n};\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction valueEnumerable(value) {\n  return { enumerable: true, value };\n}\n\nfunction valueEnumerableWritable(value) {\n  return { enumerable: true, writable: true, value };\n}\n\nlet d = {};\nlet truthy = () => true;\nlet empty = () => ({});\nlet identity = a => a;\nlet callBoth = (par, fn, self, args) => par.apply(self, args) && fn.apply(self, args);\nlet callForward = (par, fn, self, [a, b]) => fn.call(self, par.call(self, a, b), b);\nlet create = (a, b) => Object.freeze(Object.create(a, b));\n\nfunction stack(fns, def, caller) {\n  return fns.reduce((par, fn) => {\n    return function(...args) {\n      return caller(par, fn, this, args);\n    };\n  }, def);\n}\n\nfunction fnType(fn) {\n  return create(this, { fn: valueEnumerable(fn) });\n}\n\nlet reduceType = {};\nlet reduce = fnType.bind(reduceType);\nlet action = fn => reduce((ctx, ev) => !!~fn(ctx, ev) && ctx);\n\nlet guardType = {};\nlet guard = fnType.bind(guardType);\n\nfunction filter(Type, arr) {\n  return arr.filter(value => Type.isPrototypeOf(value));\n}\n\nfunction makeTransition(from, to, ...args) {\n  let guards = stack(filter(guardType, args).map(t => t.fn), truthy, callBoth);\n  let reducers = stack(filter(reduceType, args).map(t => t.fn), identity, callForward);\n  return create(this, {\n    from: valueEnumerable(from),\n    to: valueEnumerable(to),\n    guards: valueEnumerable(guards),\n    reducers: valueEnumerable(reducers)\n  });\n}\n\nlet transitionType = {};\nlet immediateType = {};\nlet transition = makeTransition.bind(transitionType);\nlet immediate = makeTransition.bind(immediateType, null);\n\nfunction enterImmediate(machine, service, event) {\n  return transitionTo(service, machine, event, this.immediates) || machine;\n}\n\nfunction transitionsToMap(transitions) {\n  let m = new Map();\n  for(let t of transitions) {\n    if(!m.has(t.from)) m.set(t.from, []);\n    m.get(t.from).push(t);\n  }\n  return m;\n}\n\nlet stateType = { enter: identity };\nfunction state(...args) {\n  let transitions = filter(transitionType, args);\n  let immediates = filter(immediateType, args);\n  let desc = {\n    final: valueEnumerable(args.length === 0),\n    transitions: valueEnumerable(transitionsToMap(transitions))\n  };\n  if(immediates.length) {\n    desc.immediates = valueEnumerable(immediates);\n    desc.enter = valueEnumerable(enterImmediate);\n  }\n  return create(stateType, desc);\n}\n\nlet invokeFnType = {\n  enter(machine2, service, event) {\n    let rn = this.fn.call(service, service.context, event);\n    if(machine.isPrototypeOf(rn))\n      return create(invokeMachineType, {\n        machine: valueEnumerable(rn),\n        transitions: valueEnumerable(this.transitions)\n      }).enter(machine2, service, event)\n    rn.then(data => service.send({ type: 'done', data }))\n      .catch(error => service.send({ type: 'error', error }));\n    return machine2;\n  }\n};\nlet invokeMachineType = {\n  enter(machine, service, event) {\n    service.child = interpret(this.machine, s => {\n      service.onChange(s);\n      if(service.child == s && s.machine.state.value.final) {\n        delete service.child;\n        service.send({ type: 'done', data: s.context });\n      }\n    }, service.context, event);\n    if(service.child.machine.state.value.final) {\n      let data = service.child.context;\n      delete service.child;\n      return transitionTo(service, machine, { type: 'done', data }, this.transitions.get('done'));\n    }\n    return machine;\n  }\n};\nfunction invoke(fn, ...transitions) {\n  let t = valueEnumerable(transitionsToMap(transitions));\n  return machine.isPrototypeOf(fn) ?\n    create(invokeMachineType, {\n      machine: valueEnumerable(fn),\n      transitions: t\n    }) :\n    create(invokeFnType, {\n      fn: valueEnumerable(fn),\n      transitions: t\n    });\n}\n\nlet machine = {\n  get state() {\n    return {\n      name: this.current,\n      value: this.states[this.current]\n    };\n  }\n};\n\nfunction createMachine(current, states, contextFn = empty) {\n  if(typeof current !== 'string') {\n    contextFn = states || empty;\n    states = current;\n    current = Object.keys(states)[0];\n  }\n  if(d._create) d._create(current, states);\n  return create(machine, {\n    context: valueEnumerable(contextFn),\n    current: valueEnumerable(current),\n    states: valueEnumerable(states)\n  });\n}\n\nfunction transitionTo(service, machine, fromEvent, candidates) {\n  let { context } = service;\n  for(let { to, guards, reducers } of candidates) {  \n    if(guards(context, fromEvent)) {\n      service.context = reducers.call(service, context, fromEvent);\n\n      let original = machine.original || machine;\n      let newMachine = create(original, {\n        current: valueEnumerable(to),\n        original: { value: original }\n      });\n\n      if (d._onEnter) d._onEnter(machine, to, service.context, context, fromEvent);\n      let state = newMachine.state.value;\n      return state.enter(newMachine, service, fromEvent);\n    }\n  }\n}\n\nfunction send(service, event) {\n  let eventName = event.type || event;\n  let { machine } = service;\n  let { value: state, name: currentStateName } = machine.state;\n  \n  if(state.transitions.has(eventName)) {\n    return transitionTo(service, machine, event, state.transitions.get(eventName)) || machine;\n  } else {\n    if(d._send) d._send(eventName, currentStateName);\n  }\n  return machine;\n}\n\nlet service = {\n  send(event) {\n    this.machine = send(this, event);\n    \n    // TODO detect change\n    this.onChange(this);\n  }\n};\n\nfunction interpret(machine, onChange, initialContext, event) {\n  let s = Object.create(service, {\n    machine: valueEnumerableWritable(machine),\n    context: valueEnumerableWritable(machine.context(initialContext, event)),\n    onChange: valueEnumerable(onChange)\n  });\n  s.send = s.send.bind(s);\n  s.machine = s.machine.state.value.enter(s.machine, s, event);\n  return s;\n}\n\nexports.action = action;\nexports.createMachine = createMachine;\nexports.d = d;\nexports.guard = guard;\nexports.immediate = immediate;\nexports.interpret = interpret;\nexports.invoke = invoke;\nexports.reduce = reduce;\nexports.state = state;\nexports.transition = transition;\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { decode, encode } from \"@msgpack/msgpack\";\nimport {\n  ContextFunction,\n  InterpretOnChangeFunction,\n  Service,\n  createMachine,\n  guard,\n  immediate,\n  interpret,\n  reduce,\n  state,\n  transition,\n} from \"robot3\";\nimport { TOKEN_EXPIRATION_SECONDS, getTemporaryAuthToken } from \"./auth\";\nimport { RequiredConfig } from \"./config\";\nimport { ApiError } from \"./response\";\nimport { isBrowser } from \"./runtime\";\nimport { ensureEndpointIdFormat, isReact, throttle } from \"./utils\";\n\n// Define the context\ninterface Context {\n  token?: string;\n  enqueuedMessage?: any;\n  websocket?: WebSocket;\n  error?: Error;\n}\n\nconst initialState: ContextFunction<Context> = () => ({\n  enqueuedMessage: undefined,\n});\n\ntype SendEvent = { type: \"send\"; message: any };\ntype AuthenticatedEvent = { type: \"authenticated\"; token: string };\ntype InitiateAuthEvent = { type: \"initiateAuth\" };\ntype UnauthorizedEvent = { type: \"unauthorized\"; error: Error };\ntype ConnectedEvent = { type: \"connected\"; websocket: WebSocket };\ntype ConnectionClosedEvent = {\n  type: \"connectionClosed\";\n  code: number;\n  reason: string;\n};\n\ntype Event =\n  | SendEvent\n  | AuthenticatedEvent\n  | InitiateAuthEvent\n  | UnauthorizedEvent\n  | ConnectedEvent\n  | ConnectionClosedEvent;\n\nfunction hasToken(context: Context): boolean {\n  return context.token !== undefined;\n}\n\nfunction noToken(context: Context): boolean {\n  return !hasToken(context);\n}\n\nfunction enqueueMessage(context: Context, event: SendEvent): Context {\n  return {\n    ...context,\n    enqueuedMessage: event.message,\n  };\n}\n\nfunction closeConnection(context: Context): Context {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    context.websocket.close();\n  }\n  return {\n    ...context,\n    websocket: undefined,\n  };\n}\n\nfunction sendMessage(context: Context, event: SendEvent): Context {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    if (event.message instanceof Uint8Array) {\n      context.websocket.send(event.message);\n    } else {\n      context.websocket.send(encode(event.message));\n    }\n\n    return {\n      ...context,\n      enqueuedMessage: undefined,\n    };\n  }\n  return {\n    ...context,\n    enqueuedMessage: event.message,\n  };\n}\n\nfunction expireToken(context: Context): Context {\n  return {\n    ...context,\n    token: undefined,\n  };\n}\n\nfunction setToken(context: Context, event: AuthenticatedEvent): Context {\n  return {\n    ...context,\n    token: event.token,\n  };\n}\n\nfunction connectionEstablished(\n  context: Context,\n  event: ConnectedEvent,\n): Context {\n  return {\n    ...context,\n    websocket: event.websocket,\n  };\n}\n\n// State machine\nconst connectionStateMachine = createMachine(\n  \"idle\",\n  {\n    idle: state(\n      transition(\"send\", \"connecting\", reduce(enqueueMessage)),\n      transition(\"expireToken\", \"idle\", reduce(expireToken)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    connecting: state(\n      transition(\"connecting\", \"connecting\"),\n      transition(\"connected\", \"active\", reduce(connectionEstablished)),\n      transition(\"connectionClosed\", \"idle\", reduce(closeConnection)),\n      transition(\"send\", \"connecting\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n      immediate(\"authRequired\", guard(noToken)),\n    ),\n    authRequired: state(\n      transition(\"initiateAuth\", \"authInProgress\"),\n      transition(\"send\", \"authRequired\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    authInProgress: state(\n      transition(\"authenticated\", \"connecting\", reduce(setToken)),\n      transition(\n        \"unauthorized\",\n        \"idle\",\n        reduce(expireToken),\n        reduce(closeConnection),\n      ),\n      transition(\"send\", \"authInProgress\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    active: state(\n      transition(\"send\", \"active\", reduce(sendMessage)),\n      transition(\"unauthorized\", \"idle\", reduce(expireToken)),\n      transition(\"connectionClosed\", \"idle\", reduce(closeConnection)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    failed: state(\n      transition(\"send\", \"failed\"),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n  },\n  initialState,\n);\n\ntype WithRequestId = {\n  request_id: string;\n};\n\n/**\n * A connection object that allows you to `send` request payloads to a\n * realtime endpoint.\n */\nexport interface RealtimeConnection<Input> {\n  send(input: Input & Partial<WithRequestId>): void;\n\n  close(): void;\n}\n\n/**\n * Options for connecting to the realtime endpoint.\n */\nexport interface RealtimeConnectionHandler<Output> {\n  /**\n   * The connection key. This is used to reuse the same connection\n   * across multiple calls to `connect`. This is particularly useful in\n   * contexts where the connection is established as part of a component\n   * lifecycle (e.g. React) and the component is re-rendered multiple times.\n   */\n  connectionKey?: string;\n\n  /**\n   * If `true`, the connection will only be established on the client side.\n   * This is useful for frameworks that reuse code for both server-side\n   * rendering and client-side rendering (e.g. Next.js).\n   *\n   * This is set to `true` by default when running on React in the server.\n   * Otherwise, it is set to `false`.\n   *\n   * Note that more SSR frameworks might be automatically detected\n   * in the future. In the meantime, you can set this to `true` when needed.\n   */\n  clientOnly?: boolean;\n\n  /**\n   * The throtle duration in milliseconds. This is used to throtle the\n   * calls to the `send` function. Realtime apps usually react to user\n   * input, which can be very frequent (e.g. fast typing or mouse/drag movements).\n   *\n   * The default value is `128` milliseconds.\n   */\n  throttleInterval?: number;\n\n  /**\n   * Configures the maximum amount of frames to store in memory before starting to drop\n   * old ones for in favor of the newer ones. It must be between `1` and `60`.\n   *\n   * The recommended is `2`. The default is `undefined` so it can be determined\n   * by the app (normally is set to the recommended setting).\n   */\n  maxBuffering?: number;\n\n  /**\n   * Callback function that is called when a result is received.\n   * @param result - The result of the request.\n   */\n  onResult(result: Output & WithRequestId): void;\n\n  /**\n   * Callback function that is called when an error occurs.\n   * @param error - The error that occurred.\n   */\n  onError?(error: ApiError<any>): void;\n}\n\nexport interface RealtimeClient {\n  /**\n   * Connect to the realtime endpoint. The default implementation uses\n   * WebSockets to connect to fal function endpoints that support WSS.\n   *\n   * @param app the app alias or identifier.\n   * @param handler the connection handler.\n   */\n  connect<Input = any, Output = any>(\n    app: string,\n    handler: RealtimeConnectionHandler<Output>,\n  ): RealtimeConnection<Input>;\n}\n\ntype RealtimeUrlParams = {\n  token: string;\n  maxBuffering?: number;\n};\n\nfunction buildRealtimeUrl(\n  app: string,\n  { token, maxBuffering }: RealtimeUrlParams,\n): string {\n  if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n    throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n  }\n  const queryParams = new URLSearchParams({\n    fal_jwt_token: token,\n  });\n  if (maxBuffering !== undefined) {\n    queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n  }\n  const appId = ensureEndpointIdFormat(app);\n  return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\n\nconst DEFAULT_THROTTLE_INTERVAL = 128;\n\nfunction isUnauthorizedError(message: any): boolean {\n  // TODO we need better protocol definition with error codes\n  return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n  NORMAL_CLOSURE: 1000,\n  GOING_AWAY: 1001,\n};\n\ntype ConnectionStateMachine = Service<typeof connectionStateMachine> & {\n  throttledSend: (\n    event: Event,\n    payload?: any,\n  ) => void | Promise<void> | undefined;\n};\n\ntype ConnectionOnChange = InterpretOnChangeFunction<\n  typeof connectionStateMachine\n>;\n\ntype RealtimeConnectionCallback = Pick<\n  RealtimeConnectionHandler<any>,\n  \"onResult\" | \"onError\"\n>;\n\nconst connectionCache = new Map<string, ConnectionStateMachine>();\nconst connectionCallbacks = new Map<string, RealtimeConnectionCallback>();\nfunction reuseInterpreter(\n  key: string,\n  throttleInterval: number,\n  onChange: ConnectionOnChange,\n) {\n  if (!connectionCache.has(key)) {\n    const machine = interpret(connectionStateMachine, onChange);\n    connectionCache.set(key, {\n      ...machine,\n      throttledSend:\n        throttleInterval > 0\n          ? throttle(machine.send, throttleInterval, true)\n          : machine.send,\n    });\n  }\n  return connectionCache.get(key) as ConnectionStateMachine;\n}\n\nconst noop = () => {\n  /* No-op */\n};\n\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection: RealtimeConnection<any> = {\n  send: noop,\n  close: noop,\n};\n\nfunction isSuccessfulResult(data: any): boolean {\n  return (\n    data.status !== \"error\" &&\n    data.type !== \"x-fal-message\" &&\n    !isFalErrorResult(data)\n  );\n}\n\ntype FalErrorResult = {\n  type: \"x-fal-error\";\n  error: string;\n  reason: string;\n};\n\nfunction isFalErrorResult(data: any): data is FalErrorResult {\n  return data.type === \"x-fal-error\";\n}\n\ntype RealtimeClientDependencies = {\n  config: RequiredConfig;\n};\n\nexport function createRealtimeClient({\n  config,\n}: RealtimeClientDependencies): RealtimeClient {\n  return {\n    connect<Input, Output>(\n      app: string,\n      handler: RealtimeConnectionHandler<Output>,\n    ): RealtimeConnection<Input> {\n      const {\n        // if running on React in the server, set clientOnly to true by default\n        clientOnly = isReact() && !isBrowser(),\n        connectionKey = crypto.randomUUID(),\n        maxBuffering,\n        throttleInterval = DEFAULT_THROTTLE_INTERVAL,\n      } = handler;\n      if (clientOnly && !isBrowser()) {\n        return NoOpConnection;\n      }\n\n      let previousState: string | undefined;\n\n      // Although the state machine is cached so we don't open multiple connections,\n      // we still need to update the callbacks so we can call the correct references\n      // when the state machine is reused. This is needed because the callbacks\n      // are passed as part of the handler object, which can be different across\n      // different calls to `connect`.\n      connectionCallbacks.set(connectionKey, {\n        onError: handler.onError,\n        onResult: handler.onResult,\n      });\n      const getCallbacks = () =>\n        connectionCallbacks.get(connectionKey) as RealtimeConnectionCallback;\n      const stateMachine = reuseInterpreter(\n        connectionKey,\n        throttleInterval,\n        ({ context, machine, send }) => {\n          const { enqueuedMessage, token } = context;\n          if (machine.current === \"active\" && enqueuedMessage) {\n            send({ type: \"send\", message: enqueuedMessage });\n          }\n          if (\n            machine.current === \"authRequired\" &&\n            token === undefined &&\n            previousState !== machine.current\n          ) {\n            send({ type: \"initiateAuth\" });\n            getTemporaryAuthToken(app, config)\n              .then((token) => {\n                send({ type: \"authenticated\", token });\n                const tokenExpirationTimeout = Math.round(\n                  TOKEN_EXPIRATION_SECONDS * 0.9 * 1000,\n                );\n                setTimeout(() => {\n                  send({ type: \"expireToken\" });\n                }, tokenExpirationTimeout);\n              })\n              .catch((error) => {\n                send({ type: \"unauthorized\", error });\n              });\n          }\n          if (\n            machine.current === \"connecting\" &&\n            previousState !== machine.current &&\n            token !== undefined\n          ) {\n            const ws = new WebSocket(\n              buildRealtimeUrl(app, { token, maxBuffering }),\n            );\n            ws.onopen = () => {\n              send({ type: \"connected\", websocket: ws });\n            };\n            ws.onclose = (event) => {\n              if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n                const { onError = noop } = getCallbacks();\n                onError(\n                  new ApiError({\n                    message: `Error closing the connection: ${event.reason}`,\n                    status: event.code,\n                  }),\n                );\n              }\n              send({ type: \"connectionClosed\", code: event.code });\n            };\n            ws.onerror = (event) => {\n              // TODO specify error protocol for identified errors\n              const { onError = noop } = getCallbacks();\n              onError(new ApiError({ message: \"Unknown error\", status: 500 }));\n            };\n            ws.onmessage = (event) => {\n              const { onResult } = getCallbacks();\n\n              // Handle binary messages as msgpack messages\n              if (event.data instanceof ArrayBuffer) {\n                const result = decode(new Uint8Array(event.data));\n                onResult(result);\n                return;\n              }\n              if (event.data instanceof Uint8Array) {\n                const result = decode(event.data);\n                onResult(result);\n                return;\n              }\n              if (event.data instanceof Blob) {\n                event.data.arrayBuffer().then((buffer) => {\n                  const result = decode(new Uint8Array(buffer));\n                  onResult(result);\n                });\n                return;\n              }\n\n              // Otherwise handle strings as plain JSON messages\n              const data = JSON.parse(event.data);\n\n              // Drop messages that are not related to the actual result.\n              // In the future, we might want to handle other types of messages.\n              // TODO: specify the fal ws protocol format\n              if (isUnauthorizedError(data)) {\n                send({\n                  type: \"unauthorized\",\n                  error: new Error(\"Unauthorized\"),\n                });\n                return;\n              }\n              if (isSuccessfulResult(data)) {\n                onResult(data);\n                return;\n              }\n              if (isFalErrorResult(data)) {\n                if (data.error === \"TIMEOUT\") {\n                  // Timeout error messages just indicate that the connection hasn't\n                  // received an incoming message for a while. We don't need to\n                  // handle them as errors.\n                  return;\n                }\n                const { onError = noop } = getCallbacks();\n                onError(\n                  new ApiError({\n                    message: `${data.error}: ${data.reason}`,\n                    // TODO better error status code\n                    status: 400,\n                    body: data,\n                  }),\n                );\n                return;\n              }\n            };\n          }\n          previousState = machine.current;\n        },\n      );\n\n      const send = (input: Input & Partial<WithRequestId>) => {\n        // Use throttled send to avoid sending too many messages\n        stateMachine.throttledSend({\n          type: \"send\",\n          message: input,\n        });\n      };\n\n      const close = () => {\n        stateMachine.send({ type: \"close\" });\n      };\n\n      return {\n        send,\n        close,\n      };\n    },\n  };\n}\n", "import { getRestApiUrl, RequiredConfig } from \"./config\";\nimport { dispatchRequest } from \"./request\";\nimport { isPlainObject } from \"./utils\";\n\n/**\n * Configuration for object lifecycle and storage behavior.\n */\nexport interface ObjectLifecyclePreference {\n  /**\n   * Duration in seconds before the object expires and is deleted.\n   * Set to a large value (e.g., 31536000000) for effectively unlimited storage.\n   *\n   * Common values:\n   * - 604800: 7 days\n   * - 2592000: 30 days\n   * - 31536000: 1 year\n   * - 31536000000: ~1000 years (effectively unlimited)\n   */\n  expiration_duration_seconds?: number;\n\n  /**\n   * Whether to allow I/O storage for this object.\n   * @default undefined (uses account default)\n   */\n  allow_io_storage?: boolean;\n}\n\n/**\n * Helper constants for common lifecycle durations.\n */\nexport const LIFECYCLE_DURATIONS = {\n  ONE_DAY: 86400,\n  ONE_WEEK: 604800,\n  ONE_MONTH: 2592000,\n  ONE_YEAR: 31536000,\n  UNLIMITED: 31536000000, // ~1000 years\n} as const;\n\n/**\n * Options for uploading a file.\n */\nexport type UploadOptions = {\n  /**\n   * Custom lifecycle configuration for the uploaded file.\n   * This object will be sent as the X-Fal-Object-Lifecycle header.\n   */\n  lifecycle?: ObjectLifecyclePreference;\n};\n\n/**\n * File support for the client. This interface establishes the contract for\n * uploading files to the server and transforming the input to replace file\n * objects with URLs.\n */\nexport interface StorageClient {\n  /**\n   * Upload a file to the server. Returns the URL of the uploaded file.\n   * @param file the file to upload\n   * @param options optional parameters, such as lifecycle configuration\n   * @returns the URL of the uploaded file\n   */\n  upload: (file: Blob, options?: UploadOptions) => Promise<string>;\n\n  /**\n   * Transform the input to replace file objects with URLs. This is used\n   * to transform the input before sending it to the server and ensures\n   * that the server receives URLs instead of file objects.\n   *\n   * @param input the input to transform.\n   * @returns the transformed input.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  transformInput: (input: Record<string, any>) => Promise<Record<string, any>>;\n}\n\ntype InitiateUploadResult = {\n  file_url: string;\n  upload_url: string;\n};\n\ntype InitiateUploadData = {\n  file_name: string;\n  content_type: string | null;\n};\n\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType: string): string {\n  const [, fileType] = contentType.split(\"/\");\n  return fileType.split(/[-;]/)[0] ?? \"bin\";\n}\n\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nasync function initiateUpload(\n  file: Blob,\n  config: RequiredConfig,\n  contentType: string,\n  lifecycle?: ObjectLifecyclePreference,\n): Promise<InitiateUploadResult> {\n  const filename =\n    file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n\n  const headers: Record<string, string> = {};\n  if (lifecycle) {\n    headers[\"X-Fal-Object-Lifecycle\"] = JSON.stringify(lifecycle);\n  }\n\n  return await dispatchRequest<InitiateUploadData, InitiateUploadResult>({\n    method: \"POST\",\n    // NOTE: We want to test V3 without making it the default at the API level\n    targetUrl: `${getRestApiUrl()}/storage/upload/initiate?storage_type=fal-cdn-v3`,\n    input: {\n      content_type: contentType,\n      file_name: filename,\n    },\n    config,\n    headers,\n  });\n}\n\n/**\n * Initiate the multipart upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nasync function initiateMultipartUpload(\n  file: Blob,\n  config: RequiredConfig,\n  contentType: string,\n  lifecycle?: ObjectLifecyclePreference,\n): Promise<InitiateUploadResult> {\n  const filename =\n    file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n\n  const headers: Record<string, string> = {};\n  if (lifecycle) {\n    headers[\"X-Fal-Object-Lifecycle\"] = JSON.stringify(lifecycle);\n  }\n\n  return await dispatchRequest<InitiateUploadData, InitiateUploadResult>({\n    method: \"POST\",\n    targetUrl: `${getRestApiUrl()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,\n    input: {\n      content_type: contentType,\n      file_name: filename,\n    },\n    config,\n    headers,\n  });\n}\n\ntype MultipartObject = {\n  partNumber: number;\n  etag: string;\n};\n\nasync function partUploadRetries(\n  uploadUrl: string,\n  chunk: Blob,\n  config: RequiredConfig,\n  tries = 3,\n): Promise<MultipartObject> {\n  if (tries === 0) {\n    throw new Error(\"Part upload failed, retries exhausted\");\n  }\n\n  const { fetch, responseHandler } = config;\n\n  try {\n    const response = await fetch(uploadUrl, {\n      method: \"PUT\",\n      body: chunk,\n    });\n\n    return (await responseHandler(response)) as MultipartObject;\n  } catch (error) {\n    return await partUploadRetries(uploadUrl, chunk, config, tries - 1);\n  }\n}\n\nasync function multipartUpload(\n  file: Blob,\n  config: RequiredConfig,\n  lifecycle?: ObjectLifecyclePreference,\n): Promise<string> {\n  const { fetch, responseHandler } = config;\n  const contentType = file.type || \"application/octet-stream\";\n  const { upload_url: uploadUrl, file_url: url } =\n    await initiateMultipartUpload(file, config, contentType, lifecycle);\n\n  // Break the file into 10MB chunks\n  const chunkSize = 10 * 1024 * 1024;\n  const chunks = Math.ceil(file.size / chunkSize);\n\n  const parsedUrl = new URL(uploadUrl);\n\n  const responses: MultipartObject[] = [];\n\n  for (let i = 0; i < chunks; i++) {\n    const start = i * chunkSize;\n    const end = Math.min(start + chunkSize, file.size);\n\n    const chunk = file.slice(start, end);\n\n    const partNumber = i + 1;\n    // {uploadUrl}/{part_number}?uploadUrlParams=...\n    const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;\n\n    responses.push(await partUploadRetries(partUploadUrl, chunk, config));\n  }\n\n  // Complete the upload\n  const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;\n  const response = await fetch(completeUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      parts: responses.map((mpart) => ({\n        partNumber: mpart.partNumber,\n        etag: mpart.etag,\n      })),\n    }),\n  });\n  await responseHandler(response);\n\n  return url;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype KeyValuePair = [string, any];\n\ntype StorageClientDependencies = {\n  config: RequiredConfig;\n};\n\nexport function createStorageClient({\n  config,\n}: StorageClientDependencies): StorageClient {\n  const ref: StorageClient = {\n    upload: async (file: Blob, options?: UploadOptions) => {\n      const lifecycle = options?.lifecycle;\n\n      // Check for 90+ MB file size to do multipart upload\n      if (file.size > 90 * 1024 * 1024) {\n        return await multipartUpload(file, config, lifecycle);\n      }\n\n      const contentType = file.type || \"application/octet-stream\";\n\n      const { fetch, responseHandler } = config;\n      const { upload_url: uploadUrl, file_url: url } = await initiateUpload(\n        file,\n        config,\n        contentType,\n        lifecycle,\n      );\n      const response = await fetch(uploadUrl, {\n        method: \"PUT\",\n        body: file,\n        headers: {\n          \"Content-Type\": file.type || \"application/octet-stream\",\n        },\n      });\n      await responseHandler(response);\n      return url;\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    transformInput: async (input: any): Promise<any> => {\n      if (Array.isArray(input)) {\n        return Promise.all(input.map((item) => ref.transformInput(item)));\n      } else if (input instanceof Blob) {\n        return await ref.upload(input);\n      } else if (isPlainObject(input)) {\n        const inputObject = input as Record<string, any>;\n        const promises = Object.entries(inputObject).map(\n          async ([key, value]): Promise<KeyValuePair> => {\n            return [key, await ref.transformInput(value)];\n          },\n        );\n        const results = await Promise.all(promises);\n        return Object.fromEntries(results);\n      }\n      // Return the input as is if it's neither an object nor a file/blob/data URI\n      return input;\n    },\n  };\n  return ref;\n}\n", "import { Config, createConfig } from \"./config\";\nimport { createQueueClient, QueueClient, QueueSubscribeOptions } from \"./queue\";\nimport { createRealtimeClient, RealtimeClient } from \"./realtime\";\nimport { buildUrl, dispatchRequest } from \"./request\";\nimport { resultResponseHandler } from \"./response\";\nimport { createStorageClient, StorageClient } from \"./storage\";\nimport { createStreamingClient, StreamingClient } from \"./streaming\";\nimport { EndpointType, InputType, OutputType } from \"./types/client\";\nimport { Result, RunOptions } from \"./types/common\";\n\n/**\n * The main client type, it provides access to simple API model usage,\n * as well as access to the `queue` and `storage` APIs.\n *\n * @see createFalClient\n */\nexport interface FalClient {\n  /**\n   * The queue client to interact with the queue API.\n   */\n  readonly queue: QueueClient;\n\n  /**\n   * The realtime client to interact with the realtime API\n   * and receive updates in real-time.\n   * @see #RealtimeClient\n   * @see #RealtimeClient.connect\n   */\n  readonly realtime: RealtimeClient;\n\n  /**\n   * The storage client to interact with the storage API.\n   */\n  readonly storage: StorageClient;\n\n  /**\n   * The streaming client to interact with the streaming API.\n   * @see #stream\n   */\n  readonly streaming: StreamingClient;\n\n  /**\n   * Runs a fal endpoint identified by its `endpointId`.\n   *\n   * @param endpointId The endpoint id, e.g. `fal-ai/fast-sdxl`.\n   * @param options The request options, including the input payload.\n   * @returns A promise that resolves to the result of the request once it's completed.\n   *\n   * @note\n   * We **do not recommend** this use for most use cases as it will block the client\n   * until the response is received. Moreover, if the connection is closed before\n   * the response is received, the request will be lost. Instead, we recommend\n   * using the `subscribe` method for most use cases.\n   */\n  run<Id extends EndpointType>(\n    endpointId: Id,\n    options: RunOptions<InputType<Id>>,\n  ): Promise<Result<OutputType<Id>>>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue.\n   *\n   * @param endpointId - The ID of the API endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns A promise that resolves to the result of the request once it's completed.\n   */\n  subscribe<Id extends EndpointType>(\n    endpointId: Id,\n    options: RunOptions<InputType<Id>> & QueueSubscribeOptions,\n  ): Promise<Result<OutputType<Id>>>;\n\n  /**\n   * Calls a fal app that supports streaming and provides a streaming-capable\n   * object as a result, that can be used to get partial results through either\n   * `AsyncIterator` or through an event listener.\n   *\n   * @param endpointId the endpoint id, e.g. `fal-ai/llavav15-13b`.\n   * @param options the request options, including the input payload.\n   * @returns the `FalStream` instance.\n   */\n  stream: StreamingClient[\"stream\"];\n}\n\n/**\n * Creates a new reference of the `FalClient`.\n * @param userConfig Optional configuration to override the default settings.\n * @returns a new instance of the `FalClient`.\n */\nexport function createFalClient(userConfig: Config = {}): FalClient {\n  const config = createConfig(userConfig);\n  const storage = createStorageClient({ config });\n  const queue = createQueueClient({ config, storage });\n  const streaming = createStreamingClient({ config, storage });\n  const realtime = createRealtimeClient({ config });\n  return {\n    queue,\n    realtime,\n    storage,\n    streaming,\n    stream: streaming.stream,\n    async run<Id extends EndpointType>(\n      endpointId: Id,\n      options: RunOptions<InputType<Id>> = {},\n    ): Promise<Result<OutputType<Id>>> {\n      const input = options.input\n        ? await storage.transformInput(options.input)\n        : undefined;\n      return dispatchRequest<InputType<Id>, Result<OutputType<Id>>>({\n        method: options.method,\n        targetUrl: buildUrl(endpointId, options),\n        input: input as InputType<Id>,\n        config: {\n          ...config,\n          responseHandler: resultResponseHandler,\n        },\n        options: {\n          signal: options.abortSignal,\n          retry: {\n            maxRetries: 3,\n            baseDelay: 500,\n            maxDelay: 15000,\n          },\n        },\n      });\n    },\n    subscribe: async (endpointId, options) => {\n      const { request_id: requestId } = await queue.submit(endpointId, options);\n      if (options.onEnqueue) {\n        options.onEnqueue(requestId);\n      }\n      await queue.subscribeToStatus(endpointId, { requestId, ...options });\n      return queue.result(endpointId, { requestId });\n    },\n  };\n}\n", "/**\n * Represents an API result, containing the data,\n *  the request ID and any other relevant information.\n */\nexport type Result<T> = {\n  data: T;\n  requestId: string;\n};\n\n/**\n * The function input and other configuration when running\n * the function, such as the HTTP method to use.\n */\nexport type RunOptions<Input> = {\n  /**\n   * The function input. It will be submitted either as query params\n   * or the body payload, depending on the `method`.\n   */\n  readonly input?: Input;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: \"get\" | \"post\" | \"put\" | \"delete\" | string;\n\n  /**\n   * The abort signal to cancel the request.\n   */\n  readonly abortSignal?: AbortSignal;\n};\n\nexport type UrlOptions = {\n  /**\n   * If `true`, the function will use the queue to run the function\n   * asynchronously and return the result in a separate call. This\n   * influences how the URL is built.\n   */\n  readonly subdomain?: string;\n\n  /**\n   * The query parameters to include in the URL.\n   */\n  readonly query?: Record<string, string>;\n\n  /**\n   * The path to append to the function URL.\n   */\n  path?: string;\n};\n\nexport type RequestLog = {\n  message: string;\n  level: \"STDERR\" | \"STDOUT\" | \"ERROR\" | \"INFO\" | \"WARN\" | \"DEBUG\";\n  source: \"USER\";\n  timestamp: string; // Using string to represent date-time format, but you could also use 'Date' type if you're going to construct Date objects.\n};\n\nexport type Metrics = {\n  inference_time: number | null;\n};\n\ninterface BaseQueueStatus {\n  status: \"IN_QUEUE\" | \"IN_PROGRESS\" | \"COMPLETED\";\n  request_id: string;\n  response_url: string;\n  status_url: string;\n  cancel_url: string;\n}\n\nexport interface InQueueQueueStatus extends BaseQueueStatus {\n  status: \"IN_QUEUE\";\n  queue_position: number;\n}\n\nexport interface InProgressQueueStatus extends BaseQueueStatus {\n  status: \"IN_PROGRESS\";\n  logs: RequestLog[];\n}\n\nexport interface CompletedQueueStatus extends BaseQueueStatus {\n  status: \"COMPLETED\";\n  logs: RequestLog[];\n  metrics?: Metrics;\n}\n\nexport type QueueStatus =\n  | InProgressQueueStatus\n  | CompletedQueueStatus\n  | InQueueQueueStatus;\n\nexport function isQueueStatus(obj: any): obj is QueueStatus {\n  return obj && obj.status && obj.response_url;\n}\n\nexport function isCompletedQueueStatus(obj: any): obj is CompletedQueueStatus {\n  return isQueueStatus(obj) && obj.status === \"COMPLETED\";\n}\n\nexport type ValidationErrorInfo = {\n  msg: string;\n  loc: Array<string | number>;\n  type: string;\n};\n\n/**\n * Represents the response from a WebHook request.\n * This is a union type that varies based on the `status` property.\n *\n * @template Payload - The type of the payload in the response. It defaults to `any`,\n * allowing for flexibility in specifying the structure of the payload.\n */\nexport type WebHookResponse<Payload = any> =\n  | {\n      /** Indicates a successful response. */\n      status: \"OK\";\n      /** The payload of the response, structure determined by the Payload type. */\n      payload: Payload;\n      /** Error is never present in a successful response. */\n      error: never;\n      /** The unique identifier for the request. */\n      request_id: string;\n    }\n  | {\n      /** Indicates an unsuccessful response. */\n      status: \"ERROR\";\n      /** The payload of the response, structure determined by the Payload type. */\n      payload: Payload;\n      /** Description of the error that occurred. */\n      error: string;\n      /** The unique identifier for the request. */\n      request_id: string;\n    };\n", "import { createFalClient, type FalClient } from \"./client\";\nimport { Config } from \"./config\";\nimport { StreamOptions } from \"./streaming\";\nimport { EndpointType, InputType } from \"./types/client\";\nimport { RunOptions } from \"./types/common\";\n\nexport { createFalClient, type FalClient } from \"./client\";\nexport { withMiddleware, withProxy } from \"./middleware\";\nexport type { RequestMiddleware } from \"./middleware\";\nexport type { QueueClient } from \"./queue\";\nexport type { RealtimeClient } from \"./realtime\";\nexport { ApiError, ValidationError } from \"./response\";\nexport type { ResponseHandler } from \"./response\";\nexport { isRetryableError } from \"./retry\";\nexport type { RetryOptions } from \"./retry\";\nexport type { StorageClient } from \"./storage\";\nexport type { FalStream, StreamingClient } from \"./streaming\";\nexport * from \"./types/common\";\nexport type {\n  QueueStatus,\n  ValidationErrorInfo,\n  WebHookResponse,\n} from \"./types/common\";\nexport { parseEndpointId } from \"./utils\";\n\ntype SingletonFalClient = {\n  config(config: Config): void;\n} & FalClient;\n\n/**\n * Creates a singleton instance of the client. This is useful as a compatibility\n * layer for existing code that uses the clients version prior to 1.0.0.\n */\nexport const fal: SingletonFalClient = (function createSingletonFalClient() {\n  let currentInstance: FalClient = createFalClient();\n  return {\n    config(config: Config) {\n      currentInstance = createFalClient(config);\n    },\n    get queue() {\n      return currentInstance.queue;\n    },\n    get realtime() {\n      return currentInstance.realtime;\n    },\n    get storage() {\n      return currentInstance.storage;\n    },\n    get streaming() {\n      return currentInstance.streaming;\n    },\n    run<Id extends EndpointType>(id: Id, options: RunOptions<InputType<Id>>) {\n      return currentInstance.run<Id>(id, options);\n    },\n    subscribe<Id extends EndpointType>(\n      endpointId: Id,\n      options: RunOptions<InputType<Id>>,\n    ) {\n      return currentInstance.subscribe<Id>(endpointId, options);\n    },\n    stream<Id extends EndpointType>(\n      endpointId: Id,\n      options: StreamOptions<InputType<Id>>,\n    ) {\n      return currentInstance.stream<Id>(endpointId, options);\n    },\n  } satisfies SingletonFalClient;\n})();\n"],
  "mappings": "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",
  "names": ["fetch", "_a", "url", "createParser", "onParse", "isFirstChunk", "buffer", "startingPosition", "startingFieldLength", "eventId", "eventName", "data", "reset", "feed", "chunk", "hasBom", "slice", "BOM", "length", "position", "discardTrailingNewline", "lineLength", "fieldLength", "character", "index", "parseEventStreamLine", "lineBuffer", "type", "id", "event", "noValue", "field", "step", "valueLength", "value", "toString", "concat", "includes", "retry", "parseInt", "Number", "isNaN", "every", "charCode", "charCodeAt", "endpointId", "options", "fetch", "_a", "reader", "_a", "encode", "decode", "size", "machine", "service", "state", "send", "token", "fetch"]
}
